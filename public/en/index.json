[{"content":"考纲 数据结构的概念；算法及其时间和空间复杂度分析 数据结构 定义：数据以及他们之间的关系 三要素：逻辑结构，存储结构，运算 算法 概念 定义：对问题求解的步骤 时间复杂度：循环，递归 选择：求语句的次数；求相应的数量级 大题 空间复杂度 循环 下面用例子解释时间复杂度的计算\n1 2 3 4 5 6 // 执行次数T(n)，数量级O(T(n)) // 循环的基本运算：最深层循环的语句 int x = 2; while(x \u0026lt; n / 2){ x = 2 * x; // 分析这条语句的执行次数 } 时间复杂度：基本运算执行次数的数量级；即关键语句执行次数和问题规模n的关系 假设执行次数为T，x的值为$2^{T+1}$，那么当$2^{T+1} \u0026gt;= n / 2$时循环停止，所以有$T \u0026gt;= log_2(n) - 2$，即$O(n) = log_2(n)$ 双重循环\n1 2 3 4 5 6 int count = 0; for(int k = 1; k \u0026lt;= n; k *= 2){ for(int i = 1; i \u0026lt;= n; i++){ ++count; // 分析这条语句 } } 可以画表格：\n外层k 内层i 基本语句的执行次数 1 1-n n 2 1-n n \u0026hellip; \u0026hellip; \u0026hellip; $2^t$ 1-n n 外层执行了$t \u0026lt; log_2(n)$次，语句时间复杂度为$log_2(n) * n$ 双重循环2\n1 2 3 4 5 6 int sum = 0; for(int i = 1; i \u0026lt; n; i *= 2){ for(int j = 0; j \u0026lt; i; j++){ ++sum; } } 外层执行了$t \u0026lt; log_2(n)$次 里层执行了$2^0 + 2^1 + \u0026hellip; + 2^t = 2^{t+1} - 1$次 时间复杂度为$2^{log_2(n)} = n$ ","permalink":"http://localhost:1313/blog/en/posts/exam/data_structure/%E6%A6%82%E8%BF%B0/","summary":"数据结构王道，绪论","title":"数据结构--绪论"},{"content":"面经，例题，课后题，代码 为什么出现了感知机，解决了什么问题，怎么解决的，优缺点是什么\n","permalink":"http://localhost:1313/blog/en/posts/exam/machine_learning/%E6%84%9F%E7%9F%A5%E6%9C%BA/","summary":"感知机部分","title":"机器学习--感知机"},{"content":"复习理论 教材663 hw2-sols.pdf (cmu.edu)\nB+树,B-link树,LSM树\u0026hellip;一个视频带你了解常用存储引擎数据结构（合集）_哔哩哔哩_bilibili 数据库底层数据结构 B树B+树LSM树 详解对比与总结-腾讯云开发者社区-腾讯云 (tencent.com)\n出现 存储的数据结构需要两个特性：适合磁盘（顺序IO，减少IO次数），并发 为了减少磁盘随机访问的次数，保证增删改查时间复杂度O(logn)\n数据结构 二叉查找树：对于每个节点，左子树数值小，右子树数值大 平衡二叉树、红黑树：通过旋转避免二叉查找树的左/右斜树情况 B树：允许每个节点有更多的子节点 B+树：数据只在叶子节点 B+树并发：数据库内核月报 (taobao.org)\n悲观锁：分支加写锁 乐观锁：加读锁，需要修改再重新加写锁 对于多核心，一个核心加锁会导致其他核心缓存失效；因此，如果存在一种自底向上加锁的策略，只有在树节点分裂或者合并或者删除的情况下向上加锁，只对被修改的树节点加锁，就可以在很大程度上减少加锁的范围和频率，从而提高B+树的多线程扩展性 Blink树 LSM：适用于多写入场景 面经 B+树比B树好在哪里？哪个层数更多？ 遍历问题：B树全部查找需要中序遍历，而B+遍历叶子节点即可，可以利用空间局部性，即利用磁盘预读原理提前将这些数据读入内存，减少了磁盘 IO 的次数 同样的大小的磁盘页，使用B+树可以容纳更多索引节点元素，在相同的数据量下，Ｂ＋树更加“矮胖”，IO操作更少 Ｂ树的查找只需找到匹配元素即可，最好情况下查找到根节点，最坏情况下查找到叶子结点，所说性能很不稳定，而Ｂ＋树每次必须查找到叶子结点，性能稳定 B+树乐观锁怎么实现？ B树的应用场景有哪些？ (1 条消息) AVL树，红黑树，B树，B+树，Trie树都分别应用在哪些现实场景中？ - 知乎 (zhihu.com) B+树和LSM-Tree的使用场景？LSM-Tree存在的问题有哪些？针对这些问题有什么解决思路？ B+树并发处理有哪些优化思路？Blink树有什么特点？ B-link Tree：一种B+Tree的并发优化 - 知乎 (zhihu.com) 为什么不用哈希表 不适用范围查询 开始lab2 Project #2 - B+Tree | CMU 15-445/645 :: Intro to Database Systems (Spring 2023)\nTask #1 - B+Tree Pages 跟随b_plus_tree_insert_test和b_plus_tree_sequential_scale_test\nsimple insert simple search simple split multiple split 疑问 header_page如何帮助并发？\ncontext有啥用\nvisualize 可以使用tools/b_plus_tree_printer\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 $ # To build the tool $ mkdir build $ cd build $ make b_plus_tree_printer -j$(nproc) $ ./bin/b_plus_tree_printer \u0026gt;\u0026gt; ... USAGE ... \u0026gt;\u0026gt; 5 5 // set leaf node and internal node max size to be 5 \u0026gt;\u0026gt; f input.txt // Insert into the tree with some inserts \u0026gt;\u0026gt; g my-tree.dot // output the tree to dot format \u0026gt;\u0026gt; q // Quit the test (Or use another terminal) // 生成图片的2种方式： http://dreampuf.github.io/GraphvizOnline/ dot -Tpng -O my-tree.dot // 和官方实现对比 https://15445.courses.cs.cmu.edu/spring2023/bpt-printer/ Graphviz Online (dreampuf.github.io)\n","permalink":"http://localhost:1313/blog/en/posts/lab/bustub/lab2-b+tree/","summary":"cmu15445 lab2 b+ tree","title":"cmu15445--lab2 b+ tree"},{"content":"复习理论 buffer pool：算子需要从disk获取数据时，可以先把数据放入buffer中，从而减少下次获取数据的时间开销 DBMS无法控制OS的pagecache，可能出现常用页被换出的情况，会导致性能下降 DBMS可以对大量数据读写，增加顺序IO，从而减少IO的开销 可以同时使用buffer和OS的小部分缓冲区，这样不影响其他进程的情况下增加DBMS的查询性能\nLRU（最近最少使用） buffer \u0026gt; disk，当buffer满了，需要替换页时，常用的算法\n146. LRU 缓存 - 力扣（LeetCode） 可以使用hash + 双链表实现 如：对于全表查询的场景，每个页只访问一次，其实没有必要放到buffer中，这样可能会把之前有用的页刷出，造成缓存污染 LRU-K 当页访问次数到达K次，才把页放入buffer中；维护两个队列，未到k次的一个，到达k次的一个，前者使用任意替换算法（如FIFO），后者使用LRU替换\n优点：相比较LRU，减少了缓存污染问题，增加了buffer命中率 缺点：需要维护未进入buffer的数据，内存开销更大 2Q（LRU-2） 使用FIFO+LRU，且k设置为2\n实际应用中LRU-2是综合各种因素后最优的选择（减少使用LRU的偶然、单次访问的缓存污染问题，维护开销不大），LRU-3或者更大的K值命中率会高，但适应性差，需要大量的数据访问才能将历史访问记录清除掉（如对于热点数据少的场景不适用，且内存开销大） 面经 介绍一下LRU，LRU-K，优缺点 lru-k 比 lru 好在哪 k怎么选择？依据？ 为什么要自己做缓存池，操作系统不是有pagecache吗？ fsync出现卡顿怎么处理 ？ 介绍一下其他的置换算法 OPT, FIFO, LFU 手撕LRU, LFU LRU-K算法的应用场景？ LRU-K算法相对于LRU算法的优势有哪些？ 缓冲池的执行流程 Page Cache的执行流程 文件系统（三）IO类型、page(buffer)cache (yuque.com) 什么情况下可以用O_Direct 如DBMS已经缓存页，没必要让OS再次缓存 如果页的大小为16KB，而磁盘只保证4KB的读写是原子的，刷脏页的时候只刷了部分页进程就崩溃了，怎么处理？ 开始lab1 Project #1 - Buffer Pool | CMU 15-445/645 :: Intro to Database Systems (Spring 2023)\nLRU-K Replacement Policy Buffer Pool Manager Read/Write Page Guards LRU-K 实现思路：从test入手，跟着头文件要求写\n使用hash，两个双链表实现：历史队列用FIFO，缓存队列用LRU\n相比于直接使用时间戳，对于需要频繁更新的场景，时间复杂度更低 还需要两个哈希表记录是否到达K次，是否可以驱逐 每个函数都上一把大锁 疑问 c++ list erase reverse_iterator 反向迭代器删除元素_std::list删除支持反向迭代器吗-CSDN博客 c++ - How to call erase with a reverse iterator - Stack Overflow\n1 v.erase(std::next(it).base()); assert和static_cast\n1 2 #define BUSTUB_ASSERT(expr, message) assert((expr) \u0026amp;\u0026amp; (message)) BUSTUB_ASSERT(frame_id \u0026lt;= static_cast\u0026lt;int\u0026gt;(replacer_size_), \u0026#34;in lruk: Remove\u0026#34;); 总结锁\n1 std::lock_guard\u0026lt;std::mutex\u0026gt;guard(latch_); 类的protected\nmake_unique\nwrite_page里： std::scoped_lock scoped_db_io_latch(db_io_latch_);\n左值引用：改名字 auto \u0026amp;a = v[idx]\nbuffer_pool_test的测试样例: random\nnoexcept 一文入魂：妈妈再也不担心我不懂C++移动语义了 - 知乎 (zhihu.com)\n测试 LRUKReplacer: test/buffer/lru_k_replacer_test.cpp BufferPoolManager: test/buffer/buffer_pool_manager_test.cpp PageGuard: test/storage/page_guard_test.cpp 1 2 3 4 5 6 7 8 9 10 // 本地测试样例没有给remove，可以自己补充 make lru_k_replacer_test -j$(nproc) ./test/lru_k_replacer_test make buffer_pool_manager_test -j$(nproc) ./test/buffer_pool_manager_test make page_guard_test -j$(nproc) ./test/page_guard_test 自己写的test\nlru_k：remove 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 TEST(LRUKReplacerTest, SelfTest1) { // 样例测试：remove LRUKReplacer lru_replacer(7, 2); // Scenario: add six elements to the replacer. We have [1,2,3,4,5]. Frame 6 is non-evictable. lru_replacer.RecordAccess(1); lru_replacer.RecordAccess(2); lru_replacer.RecordAccess(3); lru_replacer.RecordAccess(4); lru_replacer.RecordAccess(5); lru_replacer.RecordAccess(6); lru_replacer.SetEvictable(1, true); lru_replacer.SetEvictable(2, true); lru_replacer.SetEvictable(3, true); lru_replacer.SetEvictable(4, true); lru_replacer.SetEvictable(5, true); lru_replacer.SetEvictable(6, false); ASSERT_EQ(5, lru_replacer.Size()); // Scenario: Insert access history for frame 1. Now frame 1 has two access histories. // All other frames have max backward k-dist. The order of eviction is [2,3,4,5,1]. lru_replacer.RecordAccess(1); // Scenario: Evict three pages from the replacer. Elements with max k-distance should be popped // first based on LRU. int value; lru_replacer.Remove(3); lru_replacer.Evict(\u0026amp;value); ASSERT_EQ(2, value); lru_replacer.Evict(\u0026amp;value); ASSERT_EQ(4, value); ASSERT_EQ(2, lru_replacer.Size()); } page guard: read 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 TEST(PageGuardTest, SampleTest) { // 加入：move test const std::string db_name = \u0026#34;test.db\u0026#34;; const size_t buffer_pool_size = 5; const size_t k = 2; auto disk_manager = std::make_shared\u0026lt;DiskManagerUnlimitedMemory\u0026gt;(); auto bpm = std::make_shared\u0026lt;BufferPoolManager\u0026gt;(buffer_pool_size, disk_manager.get(), k); page_id_t page_id_temp; auto *page0 = bpm-\u0026gt;NewPage(\u0026amp;page_id_temp); auto guarded_page = BasicPageGuard(bpm.get(), page0); EXPECT_EQ(page0-\u0026gt;GetData(), guarded_page.GetData()); EXPECT_EQ(page0-\u0026gt;GetPageId(), guarded_page.PageId()); EXPECT_EQ(1, page0-\u0026gt;GetPinCount()); // move test auto guard_page1 = std::move(guarded_page); EXPECT_EQ(1, page0-\u0026gt;GetPinCount()); // guarded_page.Drop(); guard_page1.Drop(); EXPECT_EQ(0, page0-\u0026gt;GetPinCount()); // Shutdown the disk manager and remove the temporary file we created. disk_manager-\u0026gt;ShutDown(); } // NOLINTNEXTLINE TEST(PageGuardTest, MyReadTest) { // read test const std::string db_name = \u0026#34;test.db\u0026#34;; const size_t buffer_pool_size = 5; const size_t k = 2; auto disk_manager = std::make_shared\u0026lt;DiskManagerUnlimitedMemory\u0026gt;(); auto bpm = std::make_shared\u0026lt;BufferPoolManager\u0026gt;(buffer_pool_size, disk_manager.get(), k); page_id_t page_id_temp; auto *page0 = bpm-\u0026gt;NewPage(\u0026amp;page_id_temp); EXPECT_EQ(1, page0-\u0026gt;GetPinCount()); // read test: Drop() { auto read_guard = bpm-\u0026gt;FetchPageRead(page_id_temp); EXPECT_EQ(2, page0-\u0026gt;GetPinCount()); } EXPECT_EQ(1, page0-\u0026gt;GetPinCount()); auto guarded_page = BasicPageGuard(bpm.get(), page0); // read test: ReadPageGuard(ReadPageGuard \u0026amp;\u0026amp;that) { auto reader_guard = bpm-\u0026gt;FetchPageRead(page_id_temp); auto reader_guard_2 = ReadPageGuard(std::move(reader_guard)); EXPECT_EQ(2, page0-\u0026gt;GetPinCount()); } EXPECT_EQ(1, page0-\u0026gt;GetPinCount()); // ReadPageGuard::operator=(ReadPageGuard \u0026amp;\u0026amp;that) { auto reader_guard_1 = bpm-\u0026gt;FetchPageRead(page_id_temp); auto reader_guard_2 = bpm-\u0026gt;FetchPageRead(page_id_temp); EXPECT_EQ(3, page0-\u0026gt;GetPinCount()); reader_guard_1 = std::move(reader_guard_2); EXPECT_EQ(2, page0-\u0026gt;GetPinCount()); } EXPECT_EQ(1, page0-\u0026gt;GetPinCount()); // Shutdown the disk manager and remove the temporary file we created. disk_manager-\u0026gt;ShutDown(); } BUFFER POOL buffer逻辑： 算子需要page_id \u0026gt; buffer pool \u0026gt; disk\nbuffer pool有空位(free_list_)，直接从disk获取到buffer buffer没有空位，从replacer替换一个页 实现思路：按照test和头文件实现\nfree_list：记录空的页框(framd_id) replacer_：使用实现的LRU-K page_table_：将算子所需要的page_id对应到buffer的页框中\nRead/Write Page Guards 需要了解c++智能指针的简单实现\nC++11 智能指针【详解+实现】【面试常考】_智能指针的底层实现-CSDN博客 实现智能指针\nbasic：自动unpin read/write：自动释放锁 优化 第一次提交 总结上面的内容\n学一下perf和profiling CMU 15-445 2023 P1 优化攻略 [rank#3] - 知乎 (zhihu.com)\n1 scan_qps_0ms / 10000 + get_qps_0ms / 10000 + scan_qps_1ms + get_qps_1ms * 10 优化思路：做完2023fall再优化\n最大的性能瓶颈是随机读 diskmanager：现在刷脏时需要等待IO结束才解锁，可以将IO和buffer的其他操作分开（异步IO） 上传 1 2 3 4 5 6 7 8 // 创建写的分支 git checkout -b lru_k // 写完一部分后提交 Git add . Git commit -m \u0026#39;first p1\u0026#39; git checkout buffer_pool git merge lru_k git push origin buffer_pool:buffer_pool ","permalink":"http://localhost:1313/blog/en/posts/lab/bustub/lab1-buffer-pool/","summary":"cmu15445 lab1 buffer pool","title":"cmu15445--lab1 buffer pool"},{"content":"3-0 ","permalink":"http://localhost:1313/blog/en/posts/lab/accelerated_cpp/accelerated-c++-c3/","summary":"Accelerated C++ 第3章 使用批量数据","title":"Accelerated C++ charpter3"},{"content":"2-0 编译运行即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include\u0026lt;iostream\u0026gt; #include\u0026lt;string\u0026gt; using namespace std; int main(int argc, char const *argv[]) { cout \u0026lt;\u0026lt; \u0026#34;Please enter your first name:\u0026#34;; string name; cin \u0026gt;\u0026gt; name; const string greeting = \u0026#34;Hello, \u0026#34; + name + \u0026#34;!\u0026#34;; const int pad = 1; // greeting上下左右的填充边界字符个数 const int rows = pad * 2 + 3; // 行数 const string::size_type cols = greeting.size() + pad * 2 + 2; cout \u0026lt;\u0026lt; endl; for (int r = 0; r != rows; ++r) { string::size_type c = 0; while(c != cols){ if(r == pad + 1 \u0026amp;\u0026amp; c == pad + 1){ cout \u0026lt;\u0026lt; greeting; c += greeting.size(); }else{ if(r == 0 || r == rows - 1 || c == 0 || c == cols - 1) //第0行和最后一行以及第0列和最后一列 cout \u0026lt;\u0026lt; \u0026#34;*\u0026#34;; else cout \u0026lt;\u0026lt; \u0026#34; \u0026#34;; ++c; } } cout \u0026lt;\u0026lt; endl; } return 0; } 几个知识点\nstring::size_type：用于string或vector，相较于size_t是一个容器概念，定义和size_t相同，但是可能容器大小大于size_t最大值的情况也可以修改 size_t：为了可移植性使用，如memcpy(char* s1, const char* s2, unsigned n)，一些机器需要拷贝更大的数据，可以改为unsigned long，但是对于位数更少的机器，使用unsigned long可能有更大的开销；为了统一函数声明，使用size_t，不同机器可以使用不同的类型，如typedef size_t unsigned int 补充：sizeof()返回类型也是size_t，是一次分配内存的最大值 (1 条消息) size_t 这个类型的意义是什么？ - 知乎 (zhihu.com) unsigned int, unsigned long：32位机器都是4个字节，64位机器分别是4/8字节 string::npos：常用于搜索失败，如if(s.find(xx) == string::npos)，设置为-1，对于64位机器是2^64 - 1 如下段代码（linux64）\n1 2 3 4 5 6 7 8 9 10 string s = \u0026#34;abcd\u0026#34;; int len = 2; cout \u0026lt;\u0026lt; len - s.size() \u0026lt;\u0026lt; endl; // 18446744073709551614 cout \u0026lt;\u0026lt; sizeof(unsigned long) \u0026lt;\u0026lt; endl; // 8 cout \u0026lt;\u0026lt; sizeof(size_t) \u0026lt;\u0026lt; endl; // 8 cout \u0026lt;\u0026lt; sizeof(unsigned int) \u0026lt;\u0026lt; endl; // 4 cout \u0026lt;\u0026lt; sizeof(s.size()) \u0026lt;\u0026lt; endl; // 8 cout \u0026lt;\u0026lt; string::npos \u0026lt;\u0026lt; endl; // 18446744073709551615 2-10 using作用域：对于while{...}里的，cout可以替代std::cout使用\n","permalink":"http://localhost:1313/blog/en/posts/lab/accelerated_cpp/accelerated-c++-c2/","summary":"Accelerated C++ 第2章 循环与计数","title":"Accelerated C++ charpter2"},{"content":"1-1 有效；+左结合，用于连接两个字符串(string + string)，或一个字符串和一个字符串字面量(string + char[])，注意这是重载了string的+，而char[]是基本类型，没有重载\n1-2 无效；理由同上\n1-3 有效；{}区分了不同作用域\n1-4 都有效\n1-5 无效，因为x已经超过了作用域\n1-6 直接输出，跳过了第二次输入，因为cin遇到空格停止，而缓冲区的数据直接给到了第二次的cin 可以用getline(cin, name);输入一行的数据\n","permalink":"http://localhost:1313/blog/en/posts/lab/accelerated_cpp/accelerated-c++-c1/","summary":"Accelerated C++ 第1章 字符串的使用","title":"Accelerated C++ charpter1"},{"content":"c18 Concurrency Control 笔记 概述\n处理多个事务时，需要用到并发控制；最常用的是二阶段锁和快照隔离\n锁\n","permalink":"http://localhost:1313/blog/en/posts/lab/database_system_concepts/part7-transaction-management/","summary":"数据库系统概览\u0026ndash;并发和恢复部分，笔记 + 课后题","title":"database system concepts --  transaction"},{"content":"C15 query processing 教材内容：charpter 15, 22\n笔记 概述\n用户输入SQL语句，翻译为关系代数/语法树，经过优化器生成最终的语法树，最后执行输出 在本章中，我们研究如何评估查询计划中的单个操作以及如何估算其成本；我们将在第 16 章回到查询优化的问题。第 15.2 节概述了如何测量查询的成本。第 15.3 节到第 15.6 节讨论了单个关系代数操作的评估。多个操作可以组合成一个流水线，在流水线中，每个操作在处理输入元组时，输入元组可能正由其他操作生成。在第 15.7 节，我们探讨了如何协调查询评估计划中多个操作的执行，特别是如何使用流水线操作来避免将中间结果写入磁盘。\n测量查询的成本\n开销（执行计划 + 单个算子的开销）\n磁盘IO CPU 分布式通信 为什么不最小化响应时间？\nSQL \u0026gt; buffer \u0026gt; disk，因为buffer内容随机，所以buffer占比更多的查询会更快 对于并行IO，如RAID；T1需要访问更多的磁盘块但是可以并行读取，而T2访问很少的磁盘块但是只能串行读取 所以响应时间并不可靠，可以最小化资源开销 select\n假设$t_s$为磁盘的寻道以及旋转时间，而$t_T$为传输时间，$b_r$是一个文件中块的个数 A1：第一种情况是全表线性扫描；第二种情况是只输出对应的key，所以遍历到合适的就终止，平均即$b_r/2$ A2：b+树，先查询索引，再查询一条记录（b+树每个节点放在一个块中） A3：b+树，先查询索引，再查询该记录的非关键字属性（b是该记录占的块数，假设块连续存放） A4：第一种，同A2，使用二级索引；第二种，先找索引，再找n次记录（因为二级索引不连续） A5：范围查找，同A3 A6：二级索引的范围查找，同A4 sorting\n排序的原因\n输出需要排序 如join使用排序的数据会更快 外部归并排序\njoin\n针对等值连接，可以分类为\nnested-join naive：每个R元组都遍历一次S block：R每个块对应一次S index：对于R每个元组用索引去S里找 sort：排序 + 合并 hash：RS同时哈希 other\nduplicate elimination：排序，哈希 projection set operations：集合操作，哈希 outer join aggregation\n完整表达式的计算\n两种\nMaterialization：每个算子存储中间结果，最后输出 pipeline：不存储中间结果，每个算子的结果直接传给下一个 15.1 假设（为了简化这个练习）每个块只能容纳一个元组，并且内存最多只能容纳三个块。请展示在每次排序合并算法的过程中创建的运行（runs），当对以下元组进行排序时，按第一个属性排序：(kangaroo, 17), (wallaby, 21), (emu, 1), (wombat, 13), (platypus, 3), (lion, 8), (warthog, 4), (zebra, 11), (meerkat, 6), (hyena, 9), (hornbill, 2), (baboon, 12). 这里我感觉有问题，因为内存最多3个block，所以因该是用2-路归并（有一个块作为输出块） 15.2 考虑图15.14中的银行数据库，其中主键已下划线标出，并给出如下SQL查询：\n1 2 3 SELECT T.branch_name FROM branch T, branch S WHERE T.assets \u0026gt; S.assets AND S.branch_city = \u0026#34;Brooklyn\u0026#34; 编写一个与此查询等效的高效关系代数表达式，并说明选择的理由。\n这个表达式在可能的最小数据量上执行了θ连接。它通过将连接的右侧操作数限制为仅包含布鲁克林的分支，并且还从两个操作数中删除不必要的属性来实现这一点。\n15.3 假设关系 ( r1(A, B, C) ) 和 ( r2(C, D, E) ) 具有以下属性：( r1 ) 有 20,000 个元组，( r2 ) 有 45,000 个元组，( r1 ) 的 25 个元组可以放在一个块中，( r2 ) 的 30 个元组可以放在一个块中。使用以下每种连接策略连接 ( r1 ) 和 ( r2 ) 时，估算所需的块传输和查找次数： a. 嵌套循环连接（Nested-loop join）。\nb. 块嵌套循环连接（Block nested-loop join）。\nc. 归并连接（Merge join）。\nd. 哈希连接（Hash join）。\n关系 r1 需要 800 个块，关系 r2 需要 1500 个块。假设内存中有 M 页。如果 M \u0026gt; 800，即使使用简单的嵌套循环连接，也可以轻松完成连接操作，仅需 1500 + 800 次磁盘访问。因此，我们只考虑 M \u0026lt;= 800 页的情况。\na. 使用 r1 作为外部关系时，需要 20,000 × 1,500 + 800 = 30,000,800 次磁盘访问。 如果 r2 是外部关系，则需要 45,000 × 800 + 1,500 = 36,001,500 次磁盘访问。\nr1需要20000/25 = 800块，r2需要45000 / 30 = 1500块，正常会把小表放外层循环（即r1） b. 如果 r1 是外部关系，则需要 $\\lceil \\frac{800}{M - 1} \\rceil \\times 1500 + 800$ 次磁盘访问。如果 r2 是外部关系，则需要 $\\lceil \\frac{1500}{M - 1} \\rceil \\times 800 + 1500$ 次磁盘访问。\nc. 假设 $r_1$ 和 $r_2$ 在连接键上没有初始排序，并且 $b_b = 1$，总的排序成本（包括输出）为：\n$$ B_s = 1500 \\left(2 \\lceil \\log_{M - 1} \\left(\\frac{1500}{M}\\right) \\rceil + 2\\right) + 800 \\left(2 \\lceil \\log_{M - 1} \\left(\\frac{800}{M}\\right) \\rceil + 2\\right) $$\n磁盘访问次数。假设具有相同连接属性值的所有元组都可以放入内存中，总成本为 $B_s + 1500 + 800$ 磁盘访问次数。\nd. 我们假设不会发生溢出。由于 $r_1$ 较小，我们将其作为构建关系（build relation），而将 $r_2$ 作为探测关系（probe relation）。如果 $M \u0026gt; 800$，即不需要递归划分，则成本为 $3 \\times (1500 + 800) = 6900$ 磁盘访问次数；否则，成本为\n$$ 2 \\times (1500 + 800) \\lceil \\log_{M-1}(800) - 1 \\rceil + 1500 + 800 $$\n磁盘访问次数。\n15.4 如果索引是二级索引且在连接属性上有多个具有相同值的元组，则第15.5.3节中描述的索引嵌套循环连接算法可能效率低下。这是为什么呢？请描述一种利用排序来减少检索内部关系元组成本的方法。在什么情况下，这种算法会比混合归并连接算法更高效？\n不懂 15.5 设$r$和$s$为没有索引的关系，且假设这些关系未排序。假设内存无限，计算$r \\bowtie s$的最低成本（以I/O操作为单位）是什么？这种算法需要多少内存？\n我们可以将较小的关系完全存储在内存中，逐块读取较大的关系，并使用较大的关系作为外层关系来执行嵌套循环连接。I/O操作的数量等于 $b_r + b_s$，内存需求为 $\\min(b_r, b_s) + 2$ 页。\n15.6 考虑数据库图 15.14，其中主键下划线。假设关系 branch 上有一个关于 branch_city 的 $B^+$-树索引，且没有其他索引。列出处理涉及否定的选择操作的不同方法：\na. $\\sigma_{\\neg (branch_city \u0026lt; \u0026ldquo;Brooklyn\u0026rdquo;)}(branch)$\n使用索引定位 branch_city 字段值为 \u0026ldquo;Brooklyn\u0026rdquo; 的第一个元组。从这个元组开始，沿着指针链访问所有后续的元组，直到检索到所有相关的元组。\nb. $\\sigma_{\\neg (branch_city = \u0026ldquo;Brooklyn\u0026rdquo;)}(branch)$\n对于这个查询，索引没有作用。我们可以顺序扫描文件，并选择所有 branch_city 字段不是 \u0026ldquo;Brooklyn\u0026rdquo; 的元组。\nc. $\\sigma_{\\neg (branch_city \u0026lt; \u0026ldquo;Brooklyn\u0026rdquo; \\lor assets \u0026lt; 5000)}(branch)$\n这个查询等价于以下查询：\n$$ \\sigma_{(branch_city \\geq \u0026ldquo;Brooklyn\u0026rdquo; \\land assets \\geq 5000)}(branch) $$\n使用 branch_city 索引，我们可以通过从第一个 \u0026ldquo;Brooklyn\u0026rdquo; 元组开始，沿着指针链检索所有 branch_city 值大于或等于 \u0026ldquo;Brooklyn\u0026rdquo; 的元组。同时，对每个元组应用额外的条件 $assets \\geq 5000$。\n15.7 C16 query optimization 教材内容：chapter 16\n笔记 概述\n可以通过优化SQL表达式，以及针对不同算子使用不同的实现方式，使用不同的索引来减少开销\n三个步骤\n生成等价的表达式 注释，获取备选方案 评估并选取开销最小的方案 关系表达式转换\n等价规则\n联合选择可以分成多次选择 选择可以交换 投影只需保留最后一个 笛卡尔积+选择 等价于 theta-join theta-join可以交换 自然连接和theta-join的结合性 theta-join和选择 theta-join和投影 略 步骤\n1 2 3 4 5 6 7 8 过程 genAllEquivalent(E) EQ = {E} // 初始化等价表达式集合EQ，最初只包含表达式E 重复执行以下步骤: 将集合EQ中的每个表达式Ei与每个等价规则Rj进行匹配 如果Ei的任何子表达式ei与Rj的一侧匹配 创建一个新表达式E\u0026#39;，它与Ei相同，除了将ei转换为匹配Rj的另一侧 如果E\u0026#39;不在EQ中，则将E\u0026#39;添加到EQ中 直到无法再向EQ中添加新表达式为止 Estimating Statistics of Expression Results（成本估算统计）\n直方图：统计某个属性的频率，如当某个属性值相同的个数较多，优化器可以使用全表扫描效率而不是索引\n【认知篇】Oracle的直方图是个嘛，能干啥？_oracle智能地生成直方图有什么用-CSDN博客 Oracle直方图的详细解析 - 孙愚 - 博客园 (cnblogs.com) 选择 连接 其他操作的估计\nChoice of Evaluation Plans\n基于成本（上一节以及15章） 启发式\n尽早执行选择操作 尽早执行投影操作 left-deep join 嵌套子查询 ","permalink":"http://localhost:1313/blog/en/posts/lab/database_system_concepts/part6-query-processing-and-optimization/","summary":"数据库系统概览\u0026ndash;查询处理和优化部分，笔记 + 课后题","title":"database system concepts --  query"},{"content":"环境搭配 gradescope FAQ | CMU 15-445/645 :: Intro to Database Systems (Spring 2023) gradescope code: 2KJRB5\n15-445/645 (Non-CMU) Dashboard | Gradescope\nc++相关 C++11 Tutorial - thisPointer\n步骤 仓库地址：cmu-db/bustub: The BusTub Relational Database Management System (Educational) (github.com)\n我的环境：windows + wsl2 + clion\n仓库初始化\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // 初始化 git init git add remote github https://github.com/lbjfans/bustub.git // 克隆bustub git clone --bare https://github.com/cmu-db/bustub.git bustub-public cd bustub-public // 自己的仓库 git push https://github.com/lbjfans/bustub.git master cd .. rm -rf bustub-public git clone https://github.com/lbjfans/bustub.git // 版本回溯，建立自己的分支 cd bustub git checkout e0163edd49d2ff086f4106d1e3cb05a0b865be23 git checkout -b base // 配置，编译和测试 sudo build_support/packages.sh mkdir build cd build cmake .. make make check-tests lab0 官方：Project #0 - C++ Primer | CMU 15-445/645 :: Intro to Database Systems (Spring 2023)\n常用git\n1 2 3 4 5 6 7 8 // 创建写的分支 git checkout -b trie_test // 写完一部分后提交 Git add . Git commit -m \u0026#39;lab0\u0026#39; git checkout trie git merge trie_test Git push github trie:trie ","permalink":"http://localhost:1313/blog/en/posts/lab/bustub/lab0/","summary":"cmu15445 环境配置和lab0","title":"cmu15445--lab0"},{"content":"准备工作 博客\n索引 - Zhroyn 的学习笔记\nDBMS-存储和文件结构 - 丹尼尔奥利瓦 - 博客园 (cnblogs.com)\nChapter13 Query Optimization | Chiichen\u0026rsquo;s Blog\n答案\nDatabase System Concepts - Practice Exercises (db-book.com)\ndatabase_system_concepts_answers/Ch12_Physical_Storage_Systems/12.1.md at main · noahabe/database_system_concepts_answers (github.com)\nzju-icicles/数据库系统原理/教材/Solutions/Exercises at master · QSCTech/zju-icicles (github.com)\n翻译用GPT\n试用次数查询 (chatgpt.com)\nAIchatOS\n1 翻译这段话成中文，英文一句，中文一句。最后重新返回全部中文翻译。 存储部分\nC12 Physical Storage Systems 本章节概述\n介绍了数据存放的物理介质，如磁盘，SSD，RAID等\n12.1 SSDs可以用作内存和磁盘之间的存储层，将数据库的某些部分（例如一些关系）存储在SSD上，其余部分存储在磁盘上。另一种选择是将SSDs用作磁盘的缓冲区或缓存；频繁使用的块将保留在SSD层，而不常使用的块则保留在磁盘上。 a. 如果需要支持实时查询，并且查询必须在保证的短时间内回答，你会选择哪种方案？请解释原因。 b. 如果你有一个非常大的客户关系，其中只有一些磁盘块被频繁访问，而其他块则很少访问，你会选择哪种方案？\na. 如果需要支持实时查询，并且查询必须在保证的短时间内回答，那么选择将SSD作为存储层更为合适。这是因为将SSD作为存储层可以确保所有数据库数据都存储在SSD上，从而避免了磁盘访问延迟，使得数据检索和查询响应速度更快，能够满足实时查询的性能要求。而如果将SSD作为缓存，则仍然会存在部分数据需要从磁盘读取的情况，这可能导致不可预测的延迟，无法保证实时查询的响应时间。\nb. 对于非常大的客户关系，其中只有部分磁盘块被频繁访问，而其他块则很少访问，选择将SSD作为缓存会更为有效。这是因为在这种情况下，我们无法准确地预知哪些数据块会频繁访问，因此无法仅将一部分关系分配给SSD。此外，由于客户关系非常大，无法将全部数据都存储在SSD上。使用SSD作为缓存，可以动态地将频繁访问的块存储在SSD中，而不常访问的块则保留在磁盘上，这样能够提高整体访问速度，同时降低成本。\n12.2 一些数据库使用磁盘的方式仅使用外圈磁道上的扇区，而将内圈磁道上的扇区留空。这种做法可能的好处是什么？\n磁盘在外圈磁道上的数据传输速率会比内圈磁道更高。这是因为磁盘以恒定的速度旋转，因此当读写头位于外圈磁道时，单位时间内经过读写头的扇区数量更多，而不是内圈磁道。此外，使用仅外圈磁道可以最小化磁盘读写头的移动，从而减少磁盘访问延迟。这一点对于事务处理系统尤为重要，因为延迟会影响事务处理速率。\n2个问题\n数据传输速率 = 数据量 / 访问时间；访问时间 = 磁头移动 + 旋转 + 数据传输 扇区数量：外圈的磁道数量比内圈的多 计算机基础\u0026mdash;\u0026ndash;不同磁道扇区数是否相同？空硬盘写入数据填充磁道和扇区的顺序是什么？_一个空硬盘,文件写在哪个磁道-CSDN博客 12.3 闪存存储： a. 问：闪存转换表（用于将逻辑页号映射到物理页号）是如何在内存中创建的？ b. 问：假设你有一个64GB的闪存存储系统，页大小为4096字节。如果每个页有一个32位的地址，且表格存储为数组，那么闪存转换表的大小是多少？ c. 问：如果非常频繁地将一系列连续的逻辑页号映射到连续的物理页号，建议如何减少转换表的大小？\na. 用数组存储，索引是逻辑页号，对应物理页号\nb.\nc13 Data Storage Structures 笔记 介绍了数据如何组织存放于物理介质中，以及如何被访问（增删改查）\n文件组织 数据库里的数据以文件的形式写入磁盘中，每个文件分为多个块，块里又包括多个记录（理解为一行）\n下面介绍一条记录中的定长数据，变长数据，以及大文件如何存储\n定长记录：如下图，可以顺序存储多个记录；访问操作和数组类似\n对于删除操作，可以删除一行，然后后面的record向上移动 可以用末尾record代替删除的一行 可以用空闲链表，给record标记为已删除 变长记录：如存储变长字符串 两个问题\n记录的变长属性如何提取 如何存放在磁盘中 解决方式1：bitmap 变长部分用（偏移量，字段长度）表示（数据通过偏移量寻找），定长部分存放数据，然后通过位图表示是否为空（如0001即前三个不为空，最后一个字段为空） 解决方式2：slotted-page structure 头部记录record个数，位置以及record大小；record从尾部开始放；头部和尾部向中间增长 大文件：文件大小超过限制的大小（如MYSQL是半页），如BLOB\nrecord指向溢出页；问题是访问效率低，且备份开销大 存放外部链接；问题是授权，以及链接失效 然后介绍不同记录之间的联系\nheap file Sequential File Organization multitable clustering partitioning heap file 记录可以放在任意空闲的地方；通过free-space map可以知道空闲的空间；优点是插入和删除方便；缺点是查找开销大\nSequential File Organization 适用于按照某个属性排序好的记录，方便查找（如二分查找）；为了加快插入速度，插入时可以先通过指针域插入到overflow block中，而删除可以用逻辑删除，但是这样指针域和物理域顺序会不一致，所以还需要定时重新组织顺序 multitable clustering 常用于两个表之间经常进行连接操作，他们的数据存放于一个块中，就可以减少读取磁盘的时间；缺点是需要会增大读取单个表数据的开销；如例题13.3\npartitioning（分区）\n1 select * from transaction where year=2019 对于上述场景，只查找某一年份，可以将不同年份的数据分开存储，从而降低查找的开销 如2019年之前的数据用的少，可以放在磁盘中，而2019的数据常用，可以放在SSD中 系统目录（Data-Dictionary / system catalog） 每个关系的元数据；如关系的名字，属性（名字，值域，长度），视图，约束，用户，索引，以及存储引擎\n缓冲区 主存 \u0026gt; 缓冲区 \u0026gt; 磁盘 目标是更快的获取常用的数据 缓冲区的替换策略\nLRU MRU 列存储 适用于只使用某个属性的场景\n13.1 考虑从图13.3中的文件中删除记录5。比较以下几种实现删除操作的技术的相对优点： a. 将记录6移动到记录5占据的位置，并将记录7移动到记录6占据的位置。 b. 将记录7移动到记录5占据的位置。 c. 将记录5标记为已删除，而不移动任何记录。\na. 尽管将记录6移动到记录5的位置，并将记录7移动到记录6的位置是最直接的方法，但这种方法需要移动最多的记录，并涉及最多的访问操作。\n删去record 5，然后数组顺序上移 b. 将记录7移动到记录5的位置，移动的记录数量比选项a少，但会破坏文件中的任何排序。\n我觉得题目意思应该是把最后一个record10放到5的位置，然后数组的size\u0026ndash; c. 将记录5的空间标记为已删除，这样可以保持排序，并且不移动任何记录，但需要额外的开销来跟踪文件中的所有空闲空间。这种方法可能会导致文件中出现过多的“孔”，如果不定期进行压缩，将影响性能，因为可用的连续空闲记录减少。\n标记record5为已删除 13.2 展示图13.4中的文件在以下每一步操作后的结构： a. 插入记录 (24556, Turnamian, Finance, 98000)。 b. 删除记录 2。 c. 插入记录 (34556, Thompson, Music, 67000)\n这里空闲空间管理使用空闲链表\na. 插入到record1位置\nb. 空闲链表变为：header -\u0026gt; record2 -\u0026gt; record4 -\u0026gt; record6\nc. 插入到record2位置\n13.3 考虑关系 section 和 takes。给出这两个关系的示例实例，其中有三个课程，每个课程都有五个学生。给出这些关系使用多表聚集（multitable clustering）的文件结构。\nsection\ncourse_id course_name 001 english 002 math 003 chinese takes\ncourse_id student_id score 001 100 99 001 101 98 001 102 98 001 103 100 001 104 60 \u0026hellip; 003 199 59 multitable clustering\nheader1 header2 header3 001 english 001 100 99 001 101 98 \u0026hellip; 001 104 60 \u0026hellip; 003 chinese \u0026hellip; 003 199 59 13.4 考虑使用位图表示空闲空间图，其中对于文件中的每个块，在位图中维护两个位。如果块的填充率在0到30％之间，位为00；在30到60％之间，位为01；在60到90％之间，位为10；超过90％，位为11。即使对于非常大的文件，这种位图也可以存储在内存中。 a. 概述使用两个位来表示一个块的两个优点和一个缺点，而不是像本章前面描述的那样使用一个字节。 b. 描述如何在记录插入和删除时保持位图的最新状态。 c. 概述在搜索空闲空间和更新空闲空间信息时，位图技术相比空闲链表的优点。\na. 优点：使用两个位来表示空闲空间的空间占用较少，且空闲空间映射需要更新的次数显著减少，因为许多插入/删除操作不会导致空闲空间映射的变化。缺点：这种方法只能提供对可用空闲空间的近似估计，这可能导致空间浪费和/或增加查找记录空闲空间的搜索成本。\nb. 每次插入或删除记录时，需要检查块的使用情况是否已经改变了级别。如果改变，就更新相应的位。否则我们根本不需要访问位图，因此在大多数情况下不会产生额外的开销。\nc. 当为一个大记录或一组记录寻找空闲空间时，可能需要扫描多个空闲链表条目才能找到合适大小的空间，因此开销会更高。而使用位图时，一页位图可以存储多个页面的空闲信息，因此寻找空闲空间所需的I/O操作最小化。同样，当整个块或其大部分被删除时，使用位图技术更新空闲空间信息更加方便。\n13.5 快速确定一个块是否存在于缓冲区中，以及如果存在，它在缓冲区中的位置是非常重要的。考虑到数据库缓冲区的大小非常大，你会使用什么（内存中的）数据结构来完成这个任务？\n哈希表是大型数据库缓冲区中常用的数据结构。 hash_table[block_id] = buffer_id\n这里可以查看bustub源码 13.6 假设你们大学有大量的 takes 记录，这些记录在多年的积累中产生。请解释一下如何对 takes 关系进行表分区，并说明这种技术可能带来的好处。同时，请解释一种潜在的缺点。\n表可以根据 (year, semester) 进行分区。较旧的 takes 记录（不再经常访问的）可以存储在磁盘上，而较新的记录则可以存储在 SSD 上（它们也可以存储在像 Intel Optane 这样的存储级别内存上）。指定年份的查询可以在不读取其他年份记录的情况下得到回答。\n一个缺点是，涉及多个年份的查询会有更高的开销，因为记录可能分布在不同的关系和磁盘块中。\n13.7 给出以下每种情况的关系代数表达式和查询处理策略的示例： a. MRU（最近最常使用）比 LRU（最近最少使用）更合适的情况。 b. LRU（最近最少使用）比 MRU（最近最常使用）更合适的情况。\na. 对于两个表连接，使用nested-loop时，MRU更合适；假设缓冲区只有2个位置，两个表R1和R2，扫描R1的第一个块，然后和R2全部块连接，R2第一个块连接后就没用了，MRU算法（选择最近最常使用的替换）马上将其替换；而LRU会替换R1的第一个块，导致后续的缓冲区换进换出问题\nb. 使用merge join时，LRU更合适\n这里以后了解hash join 和 merge join 13.8 PostgreSQL通常使用一个小的缓冲区，将其余主内存的文件系统缓冲管理工作交给操作系统缓冲管理器来处理。请解释以下内容： (a) 这种方法的好处是什么？ (b) 这种方法的一个关键限制是什么？\na. 数据库系统无法预测其他进程的内存需求。通过使用较小的缓冲区，PostgreSQL确保不会占用过多的主内存。同时，即使一个块从数据库缓冲区中被逐出，只要文件系统缓冲管理器分配了足够的内存，该被逐出的页面很可能仍会被保留在文件系统缓冲区中。因此，数据库缓冲失效通常不会非常昂贵，因为块仍可能在文件系统缓冲区中被缓存。（即一是不影响其他进程，二是可以加速数据库查询）\nb. 这种方法的缺点是数据库系统可能无法控制文件系统缓冲区的替换策略。因此，操作系统可能会做出不理想的决定，导致文件系统缓冲区中的内容被不适当地逐出。\n13.9 在可变长度记录表示中，使用空值位图来指示某个属性是否为空值。 a. 对于可变长度字段，如果值为空，则在偏移量和长度字段中会存储什么？ b. 在某些应用中，元组具有大量属性，其中大多数是空值。你能否修改记录表示，使得空属性的唯一开销仅是空值位图中的一个比特位？\na. 存储什么都可以，最好都设置为0避免出错。\nb. 是的。通过将 null 位图存储在记录的开头，我们就不需要存储数据（值或偏移/长度）。这种表示方法可以节省一些存储空间，但需要额外的工作来提取记录的属性。这种表示方法特别适用于某些记录具有大量字段且大多数字段为空的应用。\n如bitmap | (offset, length) | data，查找某一属性时，若bitmap对应位是0，则找相应的(offset, length)从而找到data 13.10 解释为什么记录分配到块的方式对数据库系统性能有显著影响。\n如果我们将相关的记录分配到同一块中，我们通常可以通过一次磁盘访问来检索大部分或全部所需的记录。磁盘访问往往是数据库的瓶颈，因为这种分配策略减少了执行特定操作所需的磁盘访问次数，从而显著提高了性能。\n13.11 列出以下每种存储关系数据库策略的两个优点和两个缺点： a. 将每个关系存储在一个文件中。 b. 将多个关系（甚至整个数据库）存储在一个文件中。\na.\n优点：由于每个关系存储在自己的文件中，因此可以将经常使用的关系放在SSD上，而将不常使用的关系存储在磁盘驱动器上。假设给定文件的块在硬盘盘片上存储得很接近，从硬盘读取关系到内存会更快，因为块之间距离更近，减少了磁盘臂的移动。 缺点：由于每个关系存储在自己的文件中，因此无法执行诸如多表聚簇(multitable clustering)文件组织之类的优化。每次访问关系时，必须首先通过数据字典/系统目录来获取相应的文件路径。一旦找到路径，打开文件（例如使用 open() 系统调用）会产生开销。 b.\n优点：如果需要，可以执行诸如多表聚簇文件组织等优化。假设整个数据库存储在一个文件中（如 SQLite），我们只需要调用一次 open() 系统调用。关系之间的组织可以由DBMS自己决定，而不是OS决定。 缺点：如果数据库将所有关系存储在一个文件中，数据字典可能会在数据结构中（例如链表）记录每个关系的记录所在的块。然而，这样做会使我们失去从硬盘到主内存的顺序读取的好处。（即：由于文件中记录的位置可能是分散的，系统需要不断地跳转到不同的块进行读取，这样可能会增加磁盘的寻道时间，降低整体读取效率。）由于数据库的所有关系都存储在同一个文件中，因此无法进行优化，比如将某些关系存储在SSD上，而将其他关系存储在磁盘驱动器上（或者这样做很困难）。 13.12 在顺序文件组织中，即使当前只有一个溢出记录，为何还要使用溢出块？ 因为我们预计将来会有更多的插入记录。如果在删除操作后没有足够的空间，新的插入记录将被放置在溢出块中，并且指针将按照顺序指向这些记录。\n13.13 将 Index_metadata 关系规范化，并解释为什么使用规范化版本会导致性能下降。\n原文：figure13-12，index_attributes包括其他属性，所以需要化成第一范式 可以把index_metadata改为 index_metadata(index_name, relation_name, index_type) 而index_attributes成新的表 index_name, other_attributes\n性能下降的原因：不同表可能放在磁盘不同位置，寻找开销大；而且需要连接操作\n13.14 标准的缓冲区管理器假设每个块的大小相同，并且读取成本相同。考虑一种缓冲区管理器，它不是使用 LRU（最近最少使用算法），而是使用对象的引用率，即一个对象在最近几秒钟内被访问的频率。假设我们希望在缓冲区中存储大小和读取成本各不相同的对象（例如网页，读取成本取决于从哪个网站获取）。建议缓冲区管理器如何选择从缓冲区中驱逐哪个块。\n一个好的解决方案是使用优先队列来驱逐页面，其中优先级 (p) 是根据页面的预期重读成本来排序的，该预期重读成本由页面在过去 n 秒内的访问频率 (f)、页面的重读成本 (c) 和页面大小 (s) 决定。公式如下： p=c * s / f 缓冲区管理器应选择驱逐优先级值最低的页面，直到有足够的空闲空间来读取新引用的对象。\nC14 indexing 笔记 介绍索引14.1-5\n问题引入：如词典查单词非常麻烦，如果可以按照字母排序，查单词会简单很多；同样地，索引可以加速找到数据所在的位置\n搜索键：一个或多个属性组成，用来查找record\n索引指标：访问类型，访问、插入、删除时间，空间开销\n两种基本索引\nordered indices hash indices 顺序索引 ordered indices：按照某个属性排序建立的索引\nclustering index：索引顺序和record在文件中的顺序一致；如按单词首字母排好序的字典目录 primary indices：主键上构建的索引，通常也是clustering index secondary(nonclustering) indices：索引顺序和record在文件中顺序不一致；如乱序词典的目录 Dense index：每个键都构建索引 Sparse index：部分键构建索引；如寻找22222，可以先通过索引找到10101，再进行顺序查找；相较于dense index可以减少空间，只要从磁盘取到块于主存中，多的时间开销可以不计 Multilevel Indices：当索引过大，可以构建多层索引减少空间，类似树 顺序索引的更新和删除操作：略\nsecondary index：必须是dense index，因为对于排序好的主键可以通过顺序访问一部分来查找，而非候选码不是按顺序存放的；所以对于相同的键，需要分配桶 B+ tree 基本特点 数据指针在叶子节点中 每个节点指针域至少存满一半 根节点到叶子节点距离相同 每个节点内键都有序 某个键的左边键小，右边大；即$K(l) \u0026lt;= Ki \u0026lt; K(r)$，最左边的节点满足$K(l) \u0026lt; k$，最右边满足$k \u0026gt;= K(r)$ 查询：假设没有重复的键 单个键v：从根节点出发，利用键左边小右边大的原则直到找到叶子节点 范围查询：先找lb，再遍历叶子节点知道键\u0026gt;rb\n插入 叶子节点满了，分裂，右节点的第一个键去父节点（保留键在右节点中） 中间节点满了，分类，右节点第一个键去父节点（不保留）\n删除\n叶子下溢出：$key \u0026lt; ⌈(d−1)/2⌉$，d为节点最大的指针数量 中间节点下溢出：$pointer \u0026lt; ⌈d/2⌉$ 向兄弟节点借 合并：如下图，删除Gold，叶子节点下溢出，与兄弟节点合并；中间节点Kim没了，根节点向下补充，随后根节点也下溢出，最后两个中间节点Merge 疑问\n为什么B+常用，为什么不选择排序/哈希索引 怎么分析索引好用，增删改时间复杂度？二级索引？多值索引？ hash index Database.System.Concepts.7th.2019.4.pdf\n试用次数查询 (chatgpt.com)\nhash用途\n内存中创建索引；适用于hash-join等 内存数据库 文件中record的组织方式 in-memory hashing disk-based hashing\n支持等值查找，但不支持范围查找，因为键不是排序的\nbucket：hash_function(key) = bucket_address；一个桶可以对应多个记录的地址，即同一个键对应的多个记录用overflow chaining处理 bucket overflow：当桶数量太少，或者分布不均匀时，会发生桶溢出，即一个桶对应多个记录\nstatic hashing：提前知道记录的个数；为了减少桶溢出的概率，桶的数量通常选择为 (n / f ) × (1 + d)，其中 n表示记录的数量，f 表示每个桶可容纳的记录数量，d 是一个调整因子，通常大约为 0.2。调整因子为 0.2 时，桶中的大约 20% 的空间将保持空闲。\n静态哈希的缺点：当索引数量增加，需要重新调整桶的数量，会影响正常查询 设计hash function目标：键均匀分布于桶中；分布需要均匀（每个桶键范围相同）随机（键均匀分布桶中） dynamic hashing：linear hashing and extendable hashing，章节24.5，P1227 extendable hashing 先跳过 p695\nmultiple-key access creation of indices write-optimized index structures，如LSM tree bitmap indices indexing of spatial and tempral data 14.1 索引加快了查询处理速度，但在每个属性以及所有可能的属性组合上创建索引通常是一个坏主意。请解释原因。\n不在每个属性上都保留索引的原因包括：\n每个索引在插入和删除操作时都会增加额外的CPU时间和磁盘I/O开销。\n非主键的索引在更新时可能需要更改，尽管主键的索引可能不需要更改（这是因为更新通常不会修改主键属性）。\n每个额外的索引都需要额外的存储空间。\n对于涉及多个搜索键的查询，即使只有部分键上有索引，效率也可能不会太差。因此，当已经存在许多索引时，通过添加更多索引对数据库性能的提升较小。\n14.2 一般情况下，是否可以在同一个关系上为不同的搜索键拥有两个聚簇索引？请解释您的答案。\n一般来说，不可能在同一个关系上为不同的键拥有两个聚簇索引，因为聚集索引决定了数据的物理存储顺序，多个聚簇索引需要多次存储。 这会导致磁盘空间的浪费，并且在插入、更新和删除数据时需要维护多个聚集索引，从而降低性能。此外，多个聚集索引还会增加查询优化器的复杂性，使其难以选择最优的查询计划。查询优化器需要评估多个聚集索引的成本和选择合适的索引来执行查询，这将增加查询的执行时间。\n14.3 构造一个 B+-树，键值集合为：$$ (2, 3, 5, 7, 11, 17, 19, 23, 29, 31) $$ 假设树最初为空，值按照升序添加。构造 B+树的情况如下：\nB+ Tree Visualization (usfca.edu)\na. 每个节点可以容纳四个指针 b. 每个节点可以容纳六个指针 c. 每个节点可以容纳八个指针 同理，14.4可以去上述网站检验 14.5 考虑第651页描述的B+-树的修改后的重新分配方案。树的期望高度作为n的函数是什么？ m是nodes个数, n是每个nodes最大的记录数 问题：b+树的高度计算\n理想情况：B^height = K 14.6 编写一个B+树的函数 findRangeIterator() 的伪代码，它与函数 findRange() 类似，但返回的是一个迭代器对象，如 14.3.2 节中所描述的那样。此外，还需要提供迭代器类的伪代码，包括迭代器对象中的变量和 next() 方法。\n14.7 如果索引条目按排序顺序插入到B+树中，每个叶节点的占用率会是多少？请解释原因。 设n为单个节点的最大记录数\n升序插入1-9：如果索引条目按升序插入，新的条目会被定向到最后一个叶节点。当该叶节点被填满时，它会被分裂成两个。分裂生成的两个节点中，左节点不会再被修改，插入操作将发生在右节点。这导致叶节点的占用率约为 50%（[n/2]/n，[]是下取整），除了最后一个叶节点以外。 降序插入9-1：如果插入的键按降序排序，上述情况仍然会发生，但对称地，分裂后的右节点将不再被修改，并且除了第一个叶节点之外，所有节点的占用率为(n-1)/n\n14.8 假设你有一个包含 $n_r$ 个元组的关系r，并在其上构建一个辅助 B+ 树。 a. 给出通过每次插入一条记录来构建 B+ 树索引的成本公式。假设每个块平均可以容纳 f 个条目，并且树中叶节点以上的所有层都在内存中。 b. 假设一次随机磁盘访问需要 10 毫秒，计算在一个包含 1000 万条记录的关系上构建索引的成本。 c. 编写自底向上构建 B+ 树的伪代码，该方法在第 14.4.4 节中概述。你可以假设有一个函数可以有效地对大文件进行排序。\na.\n","permalink":"http://localhost:1313/blog/en/posts/lab/database_system_concepts/part5-storage-management-and-indexing/","summary":"数据库系统概览\u0026ndash;存储和索引部分，笔记 + 课后题","title":"database system concepts --  storage"},{"content":"环境 windows + wsl2 + clion\ncmake cmake使用详细教程（日常使用这一篇就足够了）_cmake教程-CSDN博客\n练习 0-1 计算，但是结果被丢弃\n0-2 注意添加转义符号\\ 复制到clion中会自动帮助添加转移符号\n1 2 3 4 int main(){ cout \u0026lt;\u0026lt; \u0026#34;This (\\\u0026#34;) is a quote, and this (\\\\) is a backlash.\u0026#34; \u0026lt;\u0026lt; endl; return 0; } 0-5/6 0-5：不是，因为没有中括号\n0-6：是，每个中括号都是一个作用域\n0-7/8 考察注释 0-7：无效，因为第一个/*和第一个*/匹配，后面的文字无法被编译器解释\n0-8：有效，因为//是单行注释\n0-9 1 int main() { } c++会自动补上return 0;\n","permalink":"http://localhost:1313/blog/en/posts/lab/accelerated_cpp/accelerated-c++-c0/","summary":"Accelerated C++ 第0章","title":"Accelerated C++ charpter0"},{"content":"hugo 安装 下载路径：Releases · gohugoio/hugo (github.com) 新建文件夹hugo\u0026ndash;bin，将hugo.exe放于bin中 修改环境变量：系统属性\u0026ndash;环境变量\u0026ndash;系统变量\u0026ndash;Path\u0026ndash;新增（填入hugo.exe的路径） 检查是否安装成功：cmd输入hugo version后显示版本号 papermod 快速尝试 新建工程：hugo new site blog --format yaml 安装papermod： 1 2 3 git clone https://github.com/adityatelange/hugo-PaperMod themes/PaperMod --depth=1 git init git submodule--helper add https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod --depth=1 - 如果git clone不了，可以直接下载后解压，手动放到themes文件夹下\r配置文件.yaml中加入theme: [\u0026quot;PaperMod\u0026quot;] 随便写点：hugo new post/first.md 删除：content和public中都删除相应的文件夹 启动，本地查看网页：hugo server -D 套用模板 修改hugo.yaml文件：\nblog/hugo.yaml at master · lbjfans/blog (github.com) 其他功能 这部分自定义\n搜索 Features · adityatelange/hugo-PaperMod Wiki (github.com) content/中新建search.md 1 2 3 4 5 6 7 8 --- title: \u0026#34;🔍 搜索\u0026#34; # in any language you want layout: \u0026#34;search\u0026#34; # is necessary # url: \u0026#34;/archive\u0026#34; # description: \u0026#34;Description for Search\u0026#34; summary: \u0026#34;search\u0026#34; placeholder: \u0026#34;搜索框内的默认显示\u0026#34; --- 时间轴 Features · adityatelange/hugo-PaperMod Wiki (github.com) content/中新建archives.md\n1 2 3 4 5 6 --- title: \u0026#34;⏱ 时间轴\u0026#34; layout: \u0026#34;archives\u0026#34; url: \u0026#34;/archives/\u0026#34; summary: archives --- 关于 content/中新建about.md\n1 学习博客！！！ 内容管理 content/中每个文件夹都加入_index.md文件管理相关头部信息，具体细节可上网查找 如：\n1 2 3 4 5 --- title: 其他 share: true dir: posts/other/ --- 评论系统 使用：utterances 参考：Hugo博客添加utterances评论 | 🚀 田少晗的个人博客 (shaohanyun.top) 先安装：GitHub Apps - utterances 后根据自己的仓库复制官方的代码到\\layouts\\partials\\comments.html中：utterances 最后在config.yaml中添加代码 1 2 3 4 5 utteranc: enable: true repo: \u0026#34;添加你的个人评论仓库名称\u0026#34; issueTerm: \u0026#34;title\u0026#34; theme: \u0026#34;github-light\u0026#34; 侧边目录 参考：Hugo侧边目录 | 3rd\u0026rsquo;s Blog (333rd.net) 部署github 跟随官方教程：Host on GitHub Pages | Hugo (gohugo.io)\n新建一个github repository\nSettings \u0026gt; Pages \u0026gt; Build and deployment \u0026gt; source \u0026gt; 改为github actions\n将hugo文件夹push到github中\n1 2 3 4 5 6 git config --global user.name xx git config --global user.email xx@xx git remote add origin httpxxx # github仓库中https git add . git commit -m \u0026#34;first\u0026#34; git push -u origin master hugo根目录下新建.github/workflows/hugo.yaml hugo.yaml中复制官网中的相关内容，记得修改hugo version和master name 等待部署完毕后（github参考Action中查看）即可打开个人博客 obsidian 完成上面的工作后，发文章的工作是：obsidian写文章 \u0026gt; 复制到hugo文件夹下 \u0026gt; git push；为了节省时间，可以使用obsidian插件github publisher(已改名为enveloppe)，在obsidian写完文章后即可一键传送到github page中\n最重要的是将ob的文件夹目录和hugo的目录作对应；ob中新建两个目录，content/（文章），static/images（存放图片） 注意缺点：图片只能在github和obsidian中查找，用其他md编辑器打开md文件时，最短路径导致图片无法显示；如果使用typora，可以在图片\u0026ndash;展示中选择根目录，修改为obsidian的static/images\nob中file and links修改图片存放路径（最短路径，不是相对路径），以及关闭wiki（ob和普通md文件图片路径不同） 现在，图片在ob中按照相对路径存储，但是hugo获取图片路径是/images/pic.jpg，所以需要将ob的最短路径如/pic.jpg替换为/blog/images/pic.jpg；将envelopper\u0026ndash;content中的text replacer填入： 1 2 /\\]\\(([^/\\)]+?)\\.(png|jpg|jpeg|webp|gif)/ ](/blog/images/$1.$2 接下来在ob的community plugins中下载enveloppe 我的配置如下： 展开查看\r{\r\"github\": {\r\"branch\": \"master\",\r\"automaticallyMergePR\": true,\r\"dryRun\": {\r\"enable\": false,\r\"folderName\": \"enveloppe\"\r},\r\"tokenPath\": \"%configDir%/plugins/%pluginID%/env\",\r\"api\": {\r\"tiersForApi\": \"Github Free/Pro/Team (default)\",\r\"hostname\": \"\"\r},\r\"workflow\": {\r\"commitMessage\": \"[PUBLISHER] Merge\",\r\"name\": \"\"\r},\r\"verifiedRepo\": true\r},\r\"upload\": {\r\"behavior\": \"yaml\",\r\"defaultName\": \"content/posts\",\r\"rootFolder\": \"content\",\r\"yamlFolderKey\": \"dir\",\r\"frontmatterTitle\": {\r\"enable\": false,\r\"key\": \"title\"\r},\r\"replaceTitle\": [],\r\"replacePath\": [],\r\"autoclean\": {\r\"includeAttachments\": true,\r\"enable\": false,\r\"excluded\": []\r},\r\"folderNote\": {\r\"enable\": false,\r\"rename\": \"index.md\",\r\"addTitle\": {\r\"enable\": false,\r\"key\": \"title\"\r}\r},\r\"metadataExtractorPath\": \"\"\r},\r\"conversion\": {\r\"hardbreak\": false,\r\"dataview\": true,\r\"censorText\": [],\r\"tags\": {\r\"inline\": true,\r\"exclude\": [],\r\"fields\": []\r},\r\"links\": {\r\"internal\": false,\r\"unshared\": false,\r\"wiki\": true,\r\"slugify\": \"lower\"\r}\r},\r\"embed\": {\r\"attachments\": true,\r\"overrideAttachments\": [],\r\"keySendFile\": [],\r\"notes\": false,\r\"folder\": \"static/images\",\r\"convertEmbedToLinks\": \"keep\",\r\"charConvert\": \"-\u003e\",\r\"unHandledObsidianExt\": [],\r\"sendSimpleLinks\": true\r},\r\"plugin\": {\r\"shareKey\": \"share\",\r\"excludedFolder\": [],\r\"copyLink\": {\r\"enable\": false,\r\"links\": \"\",\r\"removePart\": [],\r\"transform\": {\r\"toUri\": true,\r\"slugify\": \"lower\",\r\"applyRegex\": []\r}\r},\r\"setFrontmatterKey\": \"Set\"\r},\r\"tabsId\": \"github-configuration\"\r}\r这部分参考：Github Publisher 插件适配 Hugo 的配置 | PrintLove\n举例：如果路径和上文一致，那么在ob文件夹content/posts/other中新建文章，文章头部需加入\n1 2 3 4 5 6 --- share: true title: 标题 dir: posts/other/ date: 2024-07-14T20:40:00+08:00 --- 最后可以直接用ctrl + p，输入enveloppe的相关选项即可选择发送文章 google analytics 还可以google analytics后台查看网站访问量\n访问统计量\nAnalytics | Realtime overview (google.com) Hugo網站如何加入Search Console與Google Analytics · Ivon的部落格 (ivonblog.com) 使用Google Analytics监控GitHub Pages访问流量 | Letian’s blog (letianfeng.github.io) 总结 现在的工作流程：obsidian对应目录下写文章 \u0026gt; enveloppe上传 \u0026gt; github page查看效果\n修改样式：git pull \u0026gt; hugo根目录下修改对应文件 \u0026gt; 本地查看效果 \u0026gt; git push\n后续：未知\n参考 参考多位大佬的建站文章\n[置顶] hugo博客搭建 | PaperMod主题 | Sulv\u0026rsquo;s Blog (sulvblog.cn) PaperMod主题配置 | 🚀 田少晗的个人博客 (shaohanyun.top) 使用 Obsidian 免费建个人博客 | PrintLove https://sspai.com/post/85262 ","permalink":"http://localhost:1313/blog/en/posts/other/%E5%BB%BA%E7%AB%99%E6%95%99%E7%A8%8B/","summary":"建立个人博客，使用hugo+obsidian+github_page，不用图床","title":"hugo+obsidian+github_page个人博客"},{"content":"学习博客！！！\n","permalink":"http://localhost:1313/blog/en/about/","summary":"学习博客！！！","title":""}]