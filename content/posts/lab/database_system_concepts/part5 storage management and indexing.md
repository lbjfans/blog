---
share: true
title: database system concepts --  storage
date: 2024-07-31T14:41:00+08:00
tags:
  - lab
  - database
  - "#database_system_concepts"
  - database_system_concepts
dir: posts/lab/database_system_concepts
summary: 数据库系统概览--存储和索引部分，笔记 + 课后题
---
# 准备工作

> 博客

[索引 - Zhroyn 的学习笔记](https://zhroyn.github.io/MyNotes/%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/Chapter14%20Indexing.html)

[DBMS-存储和文件结构 - 丹尼尔奥利瓦 - 博客园 (cnblogs.com)](https://www.cnblogs.com/RDaneelOlivaw/p/8404407.html)

[Chapter13 Query Optimization | Chiichen's Blog](https://chiichen.github.io/posts/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/Chapter13%20Query%20Optimization.html)


> 答案

[Database System Concepts - Practice Exercises (db-book.com)](https://db-book.com/Practice-Exercises/index-solu.html)

[database_system_concepts_answers/Ch12_Physical_Storage_Systems/12.1.md at main · noahabe/database_system_concepts_answers (github.com)](https://github.com/noahabe/database_system_concepts_answers/blob/main/Ch12_Physical_Storage_Systems/12.1.md)

[zju-icicles/数据库系统原理/教材/Solutions/Exercises at master · QSCTech/zju-icicles (github.com)](https://github.com/QSCTech/zju-icicles/tree/master/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%95%99%E6%9D%90/Solutions/Exercises)


> 翻译用GPT

[试用次数查询 (chatgpt.com)](https://chatgpt.com/)

[AIchatOS](https://chat18.aichatos.xyz/)

```prompt
翻译这段话成中文，英文一句，中文一句。最后重新返回全部中文翻译。
```

> 存储部分


![|500x300](/blog/images/Pasted%20image%2020240729192231.png )

# C12 Physical Storage Systems

> 本章节概述

介绍了数据存放的物理介质，如磁盘，SSD，RAID等

## 12.1

>SSDs可以用作内存和磁盘之间的存储层，将数据库的某些部分（例如一些关系）存储在SSD上，其余部分存储在磁盘上。另一种选择是将SSDs用作磁盘的缓冲区或缓存；频繁使用的块将保留在SSD层，而不常使用的块则保留在磁盘上。
	a. 如果需要支持实时查询，并且查询必须在保证的短时间内回答，你会选择哪种方案？请解释原因。
	b. 如果你有一个非常大的客户关系，其中只有一些磁盘块被频繁访问，而其他块则很少访问，你会选择哪种方案？
---

**a.** 如果需要支持实时查询，并且查询必须在保证的短时间内回答，那么选择将SSD作为存储层更为合适。这是因为将SSD作为存储层可以确保所有数据库数据都存储在SSD上，从而避免了磁盘访问延迟，使得数据检索和查询响应速度更快，能够满足实时查询的性能要求。而如果将SSD作为缓存，则仍然会存在部分数据需要从磁盘读取的情况，这可能导致不可预测的延迟，无法保证实时查询的响应时间。

**b.** 对于非常大的客户关系，其中只有部分磁盘块被频繁访问，而其他块则很少访问，选择将SSD作为缓存会更为有效。这是因为在这种情况下，我们无法准确地预知哪些数据块会频繁访问，因此无法仅将一部分关系分配给SSD。此外，由于客户关系非常大，无法将全部数据都存储在SSD上。使用SSD作为缓存，可以动态地将频繁访问的块存储在SSD中，而不常访问的块则保留在磁盘上，这样能够提高整体访问速度，同时降低成本。

## 12.2

> 一些数据库使用磁盘的方式仅使用外圈磁道上的扇区，而将内圈磁道上的扇区留空。这种做法可能的好处是什么？
--------------------------------

磁盘在外圈磁道上的数据传输速率会比内圈磁道更高。这是因为磁盘以恒定的速度旋转，因此当读写头位于外圈磁道时，单位时间内经过读写头的扇区数量更多，而不是内圈磁道。此外，使用仅外圈磁道可以最小化磁盘读写头的移动，从而减少磁盘访问延迟。这一点对于事务处理系统尤为重要，因为延迟会影响事务处理速率。

2个问题
- 数据传输速率 = 数据量 / 访问时间；访问时间 = 磁头移动 + 旋转 + 数据传输
- 扇区数量：外圈的磁道数量比内圈的多
	- [计算机基础-----不同磁道扇区数是否相同？空硬盘写入数据填充磁道和扇区的顺序是什么？_一个空硬盘,文件写在哪个磁道-CSDN博客](https://blog.csdn.net/m0_37482190/article/details/86540396)
## 12.3


>闪存存储：
	a. 问：闪存转换表（用于将逻辑页号映射到物理页号）是如何在内存中创建的？
	b. 问：假设你有一个64GB的闪存存储系统，页大小为4096字节。如果每个页有一个32位的地址，且表格存储为数组，那么闪存转换表的大小是多少？
	c. 问：如果非常频繁地将一系列连续的逻辑页号映射到连续的物理页号，建议如何减少转换表的大小？
___

a. 用数组存储，索引是逻辑页号，对应物理页号

b. 






# c13 Data Storage Structures

## 笔记

> 介绍了数据如何组织存放于物理介质中，以及如何被访问（增删改查）

文件组织
数据库里的数据以文件的形式写入磁盘中，每个文件分为多个块，块里又包括多个记录（理解为一行）


> 下面介绍一条记录中的定长数据，变长数据，以及大文件如何存储


定长记录：如下图，可以顺序存储多个记录；访问操作和数组类似
- 对于删除操作，可以删除一行，然后后面的record向上移动
- 可以用末尾record代替删除的一行
- 可以用空闲链表，给record标记为已删除
![](/blog/images/Pasted%20image%2020240802142805.png)

变长记录：如存储变长字符串
两个问题
- 记录的变长属性如何提取
- 如何存放在磁盘中
解决方式1：bitmap
变长部分用（偏移量，字段长度）表示（数据通过偏移量寻找），定长部分存放数据，然后通过位图表示是否为空（如0001即前三个不为空，最后一个字段为空）
![](/blog/images/Pasted%20image%2020240802144217.png)
解决方式2：slotted-page structure
头部记录record个数，位置以及record大小；record从尾部开始放；头部和尾部向中间增长
![](/blog/images/Pasted%20image%2020240802171628.png)


大文件：文件大小超过限制的大小（如MYSQL是半页），如BLOB
- record指向溢出页；问题是访问效率低，且备份开销大
- 存放外部链接；问题是授权，以及链接失效

> 然后介绍不同记录之间的联系

- heap file
- Sequential File Organization
- multitable clustering
- partitioning

heap file
记录可以放在任意空闲的地方；通过free-space map可以知道空闲的空间；优点是插入和删除方便；缺点是查找开销大

Sequential File Organization
适用于按照某个属性排序好的记录，方便查找（如二分查找）；为了加快插入速度，插入时可以先通过指针域插入到overflow block中，而删除可以用逻辑删除，但是这样指针域和物理域顺序会不一致，所以还需要定时重新组织顺序
![](/blog/images/Pasted%20image%2020240802175905.png)


multitable clustering
常用于两个表之间经常进行连接操作，他们的数据存放于一个块中，就可以减少读取磁盘的时间；缺点是需要会增大读取单个表数据的开销；如例题13.3

partitioning（分区）
```sql
select * from transaction where year=2019
```
1. 对于上述场景，只查找某一年份，可以将不同年份的数据分开存储，从而降低查找的开销
2. 如2019年之前的数据用的少，可以放在磁盘中，而2019的数据常用，可以放在SSD中


系统目录（Data-Dictionary / system catalog）
每个关系的元数据；如关系的名字，属性（名字，值域，长度），视图，约束，用户，索引，以及存储引擎

缓冲区
主存 > 缓冲区 > 磁盘
目标是更快的获取常用的数据
缓冲区的替换策略
- LRU
- MRU

列存储
适用于只使用某个属性的场景

## 13.1

>考虑从图13.3中的文件中删除记录5。比较以下几种实现删除操作的技术的相对优点：
	a. 将记录6移动到记录5占据的位置，并将记录7移动到记录6占据的位置。
	b. 将记录7移动到记录5占据的位置。
	c. 将记录5标记为已删除，而不移动任何记录。

![500x250](/blog/images/Pasted%20image%2020240801171531.png)

a. 尽管将记录6移动到记录5的位置，并将记录7移动到记录6的位置是最直接的方法，但这种方法需要移动最多的记录，并涉及最多的访问操作。
- 删去record 5，然后数组顺序上移

b. 将记录7移动到记录5的位置，移动的记录数量比选项a少，但会破坏文件中的任何排序。
- 我觉得题目意思应该是把最后一个record10放到5的位置，然后数组的size--

c. 将记录5的空间标记为已删除，这样可以保持排序，并且不移动任何记录，但需要额外的开销来跟踪文件中的所有空闲空间。这种方法可能会导致文件中出现过多的“孔”，如果不定期进行压缩，将影响性能，因为可用的连续空闲记录减少。
- 标记record5为已删除

## 13.2


> 展示图13.4中的文件在以下每一步操作后的结构：
	a. 插入记录 (24556, Turnamian, Finance, 98000)。
	b. 删除记录 2。
	c. 插入记录 (34556, Thompson, Music, 67000)

![500x300](/blog/images/Pasted%20image%2020240801172136.png)
这里空闲空间管理使用空闲链表

a. 插入到record1位置

b. 空闲链表变为：header -> record2 -> record4 -> record6

c. 插入到record2位置

## 13.3

> 考虑关系 `section` 和 `takes`。给出这两个关系的示例实例，其中有三个课程，每个课程都有五个学生。给出这些关系使用多表聚集（multitable clustering）的文件结构。
___

section

| course_id | course_name |
| --------- | ----------- |
| 001       | english     |
| 002       | math        |
| 003       | chinese     |

takes

| course_id | student_id | score |
| --------- | ---------- | ----- |
| 001       | 100        | 99    |
| 001       | 101        | 98    |
| 001       | 102        | 98    |
| 001       | 103        | 100   |
| 001       | 104        | 60    |
| ...       |            |       |
| 003       | 199        | 59    |

multitable clustering

| header1 | header2 | header3 |
| ------- | ------- | ------- |
| 001     | english |         |
| 001     | 100     | 99      |
| 001     | 101     | 98      |
| ...     |         |         |
| 001     | 104     | 60      |
| ...     |         |         |
| 003     | chinese |         |
| ...     |         |         |
| 003     | 199     | 59      |

## 13.4

> 考虑使用位图表示空闲空间图，其中对于文件中的每个块，在位图中维护两个位。如果块的填充率在0到30％之间，位为00；在30到60％之间，位为01；在60到90％之间，位为10；超过90％，位为11。即使对于非常大的文件，这种位图也可以存储在内存中。
	a. 概述使用两个位来表示一个块的两个优点和一个缺点，而不是像本章前面描述的那样使用一个字节。
	b. 描述如何在记录插入和删除时保持位图的最新状态。
	c. 概述在搜索空闲空间和更新空闲空间信息时，位图技术相比空闲链表的优点。

a. 优点：使用两个位来表示空闲空间的空间占用较少，且空闲空间映射需要更新的次数显著减少，因为许多插入/删除操作不会导致空闲空间映射的变化。缺点：这种方法只能提供对可用空闲空间的近似估计，这可能导致空间浪费和/或增加查找记录空闲空间的搜索成本。

b. 每次插入或删除记录时，需要检查块的使用情况是否已经改变了级别。如果改变，就更新相应的位。否则我们根本不需要访问位图，因此在大多数情况下不会产生额外的开销。

c. 当为一个大记录或一组记录寻找空闲空间时，可能需要扫描多个空闲链表条目才能找到合适大小的空间，因此开销会更高。而使用位图时，一页位图可以存储多个页面的空闲信息，因此寻找空闲空间所需的I/O操作最小化。同样，当整个块或其大部分被删除时，使用位图技术更新空闲空间信息更加方便。

## 13.5

> 快速确定一个块是否存在于缓冲区中，以及如果存在，它在缓冲区中的位置是非常重要的。考虑到数据库缓冲区的大小非常大，你会使用什么（内存中的）数据结构来完成这个任务？

哈希表是大型数据库缓冲区中常用的数据结构。
`hash_table[block_id] = buffer_id`
- 这里可以查看bustub源码

## 13.6

> 假设你们大学有大量的 `takes` 记录，这些记录在多年的积累中产生。请解释一下如何对 `takes` 关系进行表分区，并说明这种技术可能带来的好处。同时，请解释一种潜在的缺点。


表可以根据 `(year, semester)` 进行分区。较旧的 `takes` 记录（不再经常访问的）可以存储在磁盘上，而较新的记录则可以存储在 SSD 上（它们也可以存储在像 Intel Optane 这样的存储级别内存上）。指定年份的查询可以在不读取其他年份记录的情况下得到回答。

一个缺点是，涉及多个年份的查询会有更高的开销，因为记录可能分布在不同的关系和磁盘块中。

## 13.7

> 给出以下每种情况的关系代数表达式和查询处理策略的示例：
	a. MRU（最近最常使用）比 LRU（最近最少使用）更合适的情况。
	b. LRU（最近最少使用）比 MRU（最近最常使用）更合适的情况。
---

a. 对于两个表连接，使用nested-loop时，MRU更合适；假设缓冲区只有2个位置，两个表R1和R2，扫描R1的第一个块，然后和R2全部块连接，R2第一个块连接后就没用了，MRU算法（选择最近最常使用的替换）马上将其替换；而LRU会替换R1的第一个块，导致后续的缓冲区换进换出问题

b. 使用merge join时，LRU更合适
- 这里以后了解hash join 和 merge join

## 13.8

> PostgreSQL通常使用一个小的缓冲区，将其余主内存的文件系统缓冲管理工作交给操作系统缓冲管理器来处理。请解释以下内容：
	(a) 这种方法的好处是什么？
	(b) 这种方法的一个关键限制是什么？
---
	

a. 数据库系统无法预测其他进程的内存需求。通过使用较小的缓冲区，PostgreSQL确保不会占用过多的主内存。同时，即使一个块从数据库缓冲区中被逐出，只要文件系统缓冲管理器分配了足够的内存，该被逐出的页面很可能仍会被保留在文件系统缓冲区中。因此，数据库缓冲失效通常不会非常昂贵，因为块仍可能在文件系统缓冲区中被缓存。（即一是不影响其他进程，二是可以加速数据库查询）

b. 这种方法的缺点是数据库系统可能无法控制文件系统缓冲区的替换策略。因此，操作系统可能会做出不理想的决定，导致文件系统缓冲区中的内容被不适当地逐出。

## 13.9

> 在可变长度记录表示中，使用空值位图来指示某个属性是否为空值。
	a. 对于可变长度字段，如果值为空，则在偏移量和长度字段中会存储什么？
	b. 在某些应用中，元组具有大量属性，其中大多数是空值。你能否修改记录表示，使得空属性的唯一开销仅是空值位图中的一个比特位？
---

a.  存储什么都可以，最好都设置为0避免出错。


b. 是的。通过将 null 位图存储在记录的开头，我们就不需要存储数据（值或偏移/长度）。这种表示方法可以节省一些存储空间，但需要额外的工作来提取记录的属性。这种表示方法特别适用于某些记录具有大量字段且大多数字段为空的应用。
- 如`bitmap | (offset, length) | data`，查找某一属性时，若bitmap对应位是0，则找相应的(offset, length)从而找到data

## 13.10

> 解释为什么记录分配到块的方式对数据库系统性能有显著影响。
---

如果我们将相关的记录分配到同一块中，我们通常可以通过一次磁盘访问来检索大部分或全部所需的记录。磁盘访问往往是数据库的瓶颈，因为这种分配策略减少了执行特定操作所需的磁盘访问次数，从而显著提高了性能。

## 13.11

> 列出以下每种存储关系数据库策略的两个优点和两个缺点：
	a. 将每个关系存储在一个文件中。
	b. 将多个关系（甚至整个数据库）存储在一个文件中。
---

a. 
- 优点：由于每个关系存储在自己的文件中，因此可以将经常使用的关系放在SSD上，而将不常使用的关系存储在磁盘驱动器上。假设给定文件的块在硬盘盘片上存储得很接近，从硬盘读取关系到内存会更快，因为块之间距离更近，减少了磁盘臂的移动。
- 缺点：由于每个关系存储在自己的文件中，因此无法执行诸如多表聚簇(multitable clustering)文件组织之类的优化。每次访问关系时，必须首先通过数据字典/系统目录来获取相应的文件路径。一旦找到路径，打开文件（例如使用 open() 系统调用）会产生开销。

b. 
- 优点：如果需要，可以执行诸如多表聚簇文件组织等优化。假设整个数据库存储在一个文件中（如 SQLite），我们只需要调用一次 `open()` 系统调用。关系之间的组织可以由DBMS自己决定，而不是OS决定。
- 缺点：如果数据库将所有关系存储在一个文件中，数据字典可能会在数据结构中（例如链表）记录每个关系的记录所在的块。然而，这样做会使我们失去从硬盘到主内存的顺序读取的好处。（即：由于文件中记录的位置可能是分散的，系统需要不断地跳转到不同的块进行读取，这样可能会增加磁盘的寻道时间，降低整体读取效率。）由于数据库的所有关系都存储在同一个文件中，因此无法进行优化，比如将某些关系存储在SSD上，而将其他关系存储在磁盘驱动器上（或者这样做很困难）。

## 13.12

> 在顺序文件组织中，即使当前只有一个溢出记录，为何还要使用溢出块？
>---

因为我们预计将来会有更多的插入记录。如果在删除操作后没有足够的空间，新的插入记录将被放置在溢出块中，并且指针将按照顺序指向这些记录。


## 13.13

> 将 `Index_metadata` 关系规范化，并解释为什么使用规范化版本会导致性能下降。
---

原文：figure13-12，index_attributes包括其他属性，所以需要化成第一范式
![](/blog/images/Pasted%20image%2020240804131043.png)
可以把index_metadata改为
`index_metadata(index_name, relation_name, index_type)`
而index_attributes成新的表
`index_name, other_attributes`

性能下降的原因：不同表可能放在磁盘不同位置，寻找开销大；而且需要连接操作

## 13.14

> 标准的缓冲区管理器假设每个块的大小相同，并且读取成本相同。考虑一种缓冲区管理器，它不是使用 LRU（最近最少使用算法），而是使用对象的引用率，即一个对象在最近几秒钟内被访问的频率。假设我们希望在缓冲区中存储大小和读取成本各不相同的对象（例如网页，读取成本取决于从哪个网站获取）。建议缓冲区管理器如何选择从缓冲区中驱逐哪个块。
---

一个好的解决方案是使用优先队列来驱逐页面，其中优先级 (p) 是根据页面的预期重读成本来排序的，该预期重读成本由页面在过去 n 秒内的访问频率 (f)、页面的重读成本 (c) 和页面大小 (s) 决定。公式如下：
p=c * s / f
缓冲区管理器应选择驱逐优先级值最低的页面，直到有足够的空闲空间来读取新引用的对象。

# C14 indexing

## 笔记

> 介绍索引14.1-5

问题引入：如词典查单词非常麻烦，如果可以按照字母排序，查单词会简单很多；同样地，索引可以加速找到数据所在的位置

搜索键：一个或多个属性组成，用来查找record

索引指标：访问类型，访问、插入、删除时间，空间开销

两种基本索引
- ordered indices
- hash indices

### 顺序索引

ordered indices：按照某个属性排序建立的索引
- clustering index：索引顺序和record在文件中的顺序一致；如按单词首字母排好序的字典目录
- primary indices：主键上构建的索引，通常也是clustering index
- secondary(nonclustering) indices：索引顺序和record在文件中顺序不一致；如乱序词典的目录
- Dense index：每个键都构建索引
![](/blog/images/Pasted%20image%2020240803012711.png)
- Sparse index：部分键构建索引；如寻找22222，可以先通过索引找到10101，再进行顺序查找；相较于dense index可以减少空间，只要从磁盘取到块于主存中，多的时间开销可以不计
![](/blog/images/Pasted%20image%2020240803011709.png)
- Multilevel Indices：当索引过大，可以构建多层索引减少空间，类似树
![500*400](/blog/images/Pasted%20image%2020240803011658.png)

顺序索引的更新和删除操作：略

secondary index：必须是dense index，因为对于排序好的主键可以通过顺序访问一部分来查找，而非候选码不是按顺序存放的；所以对于相同的键，需要分配桶
![](/blog/images/Pasted%20image%2020240803020028.png)

### B+ tree

基本特点
![](/blog/images/Pasted%20image%2020240816020905.png)
- 数据指针在叶子节点中
- 每个节点指针域至少存满一半
- 根节点到叶子节点距离相同
- 每个节点内键都有序
- 某个键的左边键小，右边大；即$K(l) <= Ki < K(r)$，最左边的节点满足$K(l) < k$，最右边满足$k >= K(r)$

查询：假设没有重复的键
单个键v：从根节点出发，利用键左边小右边大的原则直到找到叶子节点
范围查询：先找lb，再遍历叶子节点知道键>rb

插入
叶子节点满了，分裂，右节点的第一个键去父节点（保留键在右节点中）
中间节点满了，分类，右节点第一个键去父节点（不保留）

删除
- 叶子下溢出：$key < ⌈(d−1)/2⌉$，d为节点最大的指针数量
- 中间节点下溢出：$pointer < ⌈d/2⌉$
向兄弟节点借
合并：如下图，删除`Gold`，叶子节点下溢出，与兄弟节点合并；中间节点`Kim`没了，根节点向下补充，随后根节点也下溢出，最后两个中间节点Merge
![](/blog/images/Pasted%20image%2020240816151253.png)
![](/blog/images/Pasted%20image%2020240816151303.png)



疑问
- 为什么B+常用，为什么不选择排序/哈希索引
- 怎么分析索引好用，增删改时间复杂度？二级索引？多值索引？

### hash index

[Database.System.Concepts.7th.2019.4.pdf](file:///D:/code_app/cmu15445/Database.System.Concepts.7th.2019.4.pdf)

[试用次数查询 (chatgpt.com)](https://chatgpt.com/c/bb891cd3-c58e-4fd0-b143-c4fdc8603f7d)

hash用途
- 内存中创建索引；适用于hash-join等
- 内存数据库
- 文件中record的组织方式

in-memory hashing
disk-based hashing

支持等值查找，但不支持范围查找，因为键不是排序的

bucket：hash_function(key) = bucket_address；一个桶可以对应多个记录的地址，即同一个键对应的多个记录用overflow chaining处理
bucket overflow：当桶数量太少，或者分布不均匀时，会发生桶溢出，即一个桶对应多个记录

static hashing：提前知道记录的个数；为了减少桶溢出的概率，桶的数量通常选择为 (n / f ) × (1 + d)，其中 n表示记录的数量，f 表示每个桶可容纳的记录数量，d 是一个调整因子，通常大约为 0.2。调整因子为 0.2 时，桶中的大约 20% 的空间将保持空闲。
- 静态哈希的缺点：当索引数量增加，需要重新调整桶的数量，会影响正常查询
- 设计hash function目标：键均匀分布于桶中；分布需要均匀（每个桶键范围相同）随机（键均匀分布桶中）

dynamic hashing：linear hashing and extendable hashing，章节24.5，P1227
extendable hashing
![500*400](/blog/images/Pasted%20image%2020240803150429.png)



### 先跳过

p695
- multiple-key access
- creation of indices
- write-optimized index structures，如LSM tree
- bitmap indices
- indexing of spatial and tempral data


## 14.1

> 索引加快了查询处理速度，但在每个属性以及所有可能的属性组合上创建索引通常是一个坏主意。请解释原因。
---

不在每个属性上都保留索引的原因包括：

- 每个索引在插入和删除操作时都会增加额外的CPU时间和磁盘I/O开销。

- 非主键的索引在更新时可能需要更改，尽管主键的索引可能不需要更改（这是因为更新通常不会修改主键属性）。

- 每个额外的索引都需要额外的存储空间。

- 对于涉及多个搜索键的查询，即使只有部分键上有索引，效率也可能不会太差。因此，当已经存在许多索引时，通过添加更多索引对数据库性能的提升较小。

## 14.2

> 一般情况下，是否可以在同一个关系上为不同的搜索键拥有两个聚簇索引？请解释您的答案。
---

一般来说，不可能在同一个关系上为不同的键拥有两个聚簇索引，因为聚集索引决定了数据的物理存储顺序，多个聚簇索引需要多次存储。
这会导致磁盘空间的浪费，并且在插入、更新和删除数据时需要维护多个聚集索引，从而降低性能。此外，多个聚集索引还会增加查询优化器的复杂性，使其难以选择最优的查询计划。查询优化器需要评估多个聚集索引的成本和选择合适的索引来执行查询，这将增加查询的执行时间。

## 14.3

> 构造一个 B+-树，键值集合为：$$ (2, 3, 5, 7, 11, 17, 19, 23, 29, 31) $$ 假设树最初为空，值按照升序添加。构造 B+树的情况如下：

[B+ Tree Visualization (usfca.edu)](https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html)

a. 每个节点可以容纳四个指针
![](/blog/images/Pasted%20image%2020240804141850.png)

b. 每个节点可以容纳六个指针
![](/blog/images/Pasted%20image%2020240804142008.png)

c. 每个节点可以容纳八个指针
![500](/blog/images/Pasted%20image%2020240804142217.png)

- 同理，14.4可以去上述网站检验

## 14.5

> 考虑第651页描述的B+-树的修改后的重新分配方案。树的期望高度作为n的函数是什么？
> ---

![](/blog/images/Pasted%20image%2020240806131459.png)
- m是nodes个数, n是每个nodes最大的记录数

问题：b+树的高度计算
- 理想情况：B^height = K

## 14.6

> 编写一个B+树的函数 `findRangeIterator()` 的伪代码，它与函数 `findRange()` 类似，但返回的是一个迭代器对象，如 14.3.2 节中所描述的那样。此外，还需要提供迭代器类的伪代码，包括迭代器对象中的变量和 `next()` 方法。
---

## 14.7

> 如果索引条目按排序顺序插入到B+树中，每个叶节点的占用率会是多少？请解释原因。
> ---

设n为单个节点的最大记录数

![](/blog/images/Pasted%20image%2020240806135232.png)
升序插入1-9：如果索引条目按升序插入，新的条目会被定向到最后一个叶节点。当该叶节点被填满时，它会被分裂成两个。分裂生成的两个节点中，左节点不会再被修改，插入操作将发生在右节点。这导致叶节点的占用率约为 50%（[n/2]/n，[]是下取整），除了最后一个叶节点以外。
![](/blog/images/Pasted%20image%2020240806135143.png)
降序插入9-1：如果插入的键按降序排序，上述情况仍然会发生，但对称地，分裂后的右节点将不再被修改，并且除了第一个叶节点之外，所有节点的占用率为`(n-1)/n`

## 14.8

> 假设你有一个包含 $n_r$ 个元组的关系r，并在其上构建一个辅助 B+ 树。
	a. 给出通过每次插入一条记录来构建 B+ 树索引的成本公式。假设每个块平均可以容纳 f 个条目，并且树中叶节点以上的所有层都在内存中。
	b. 假设一次随机磁盘访问需要 10 毫秒，计算在一个包含 1000 万条记录的关系上构建索引的成本。
	c. 编写自底向上构建 B+ 树的伪代码，该方法在第 14.4.4 节中概述。你可以假设有一个函数可以有效地对大文件进行排序。
---

a. 

